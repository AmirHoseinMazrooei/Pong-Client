#include <asio.hpp>
#include <iostream>
#include <string>
#include <thread>
#include <mutex>
#include <vector>
#include <SDL.h>
#include "flatbuffers/flatbuffers.h"
#include "game_state.h" // Generated by FlatBuffers compiler
#include "GameObject.h"
#include "Scene.h"
#include "SDLComponents.h"
#include <SDL_ttf.h>
#include "utils.h"
using asio::ip::tcp;

std::mutex gameStateMutex;
bool running = true;
bool isServerGameStarted = false;
struct GameState {
	int32_t player1_y, player2_y;
	int32_t ball_x, ball_y;
	int32_t player1_score, player2_score;
	int32_t ball_x_velocity, ball_y_velocity;
};

// Shared game state
GameState gameState = { 400, 400, 600, 400 ,0,0,1,1 };

class PongClient {
public:
	PongClient(asio::io_context& io_context)
		: io_context_(io_context), socket_(io_context) {}

	void connect(const std::string& host, const std::string& port) {
		tcp::resolver resolver(io_context_);
		auto endpoints = resolver.resolve(host, port);
		asio::connect(socket_, endpoints);
		std::cout << "Connected to server.\n";
	}

	void sendInput(const std::string& input) {
		std::lock_guard<std::mutex> lock(writeMutex);
		asio::write(socket_, asio::buffer(input));
	}

	void receiveGameState() {
		try {
			while (running) {
				std::cout << "receiveGameState loop started. Running: " << running << std::endl;

				// Read the size of the incoming FlatBuffers message
				uint32_t size_net;
				asio::error_code ec;
				asio::read(socket_, asio::buffer(&size_net, sizeof(size_net)), ec);
				if (ec == asio::error::eof || ec == asio::error::connection_reset) {
					std::cout << "Server disconnected while reading size.\n";
					running = false;
					break;
				}
				else if (ec) {
					std::cerr << "Error reading size: " << ec.message() << std::endl;
					throw asio::system_error(ec);
				}

				uint32_t size = ntohl(size_net);  // Convert size to host byte order
				std::cout << "Message size (after ntohl): " << size << std::endl;

				// Read the FlatBuffers data
				std::vector<uint8_t> buffer(size);
				asio::read(socket_, asio::buffer(buffer.data(), size), ec);
				if (ec == asio::error::eof || ec == asio::error::connection_reset) {
					std::cout << "Server disconnected while reading data.\n";
					running = false;
					break;
				}
				else if (ec) {
					std::cerr << "Error reading data: " << ec.message() << std::endl;
					throw asio::system_error(ec);
				}

				// Verify and parse the FlatBuffers data
				flatbuffers::Verifier verifier(buffer.data(), buffer.size());
				if (!PongGame::VerifyGameStateBuffer(verifier)) {
					std::cerr << "Received invalid GameState FlatBuffer.\n";
					continue;
				}

				const PongGame::GameState* receivedState = PongGame::GetGameState(buffer.data());

				if (receivedState) {
					GameState newState;
					newState.player1_y = receivedState->player1_y();
					newState.player2_y = receivedState->player2_y();
					newState.ball_x = receivedState->ball()->x();
					newState.ball_y = receivedState->ball()->y();
					newState.player1_score = receivedState->player1_score();
					newState.player2_score = receivedState->player2_score();
					newState.ball_x_velocity = receivedState->ball_velocity()->x();
					newState.ball_y_velocity = receivedState->ball_velocity()->y();

					{
						std::lock_guard<std::mutex> lock(gameStateMutex);
						gameState = newState;
						isServerGameStarted = true;
					}

					// Log the updated game state
					std::cout << "Updated GameState:"
						<< " P1_Y=" << gameState.player1_y
						<< " P2_Y=" << gameState.player2_y
						<< " Ball_X=" << gameState.ball_x
						<< " Ball_Y=" << gameState.ball_y << std::endl;
				}
				else {
					std::cerr << "Failed to parse GameState from FlatBuffers data.\n";
				}

				std::cout << "End of receiveGameState loop iteration.\n";
			}

			std::cout << "Exiting receiveGameState loop.\n";
		}
		catch (const std::exception& e) {
			std::cerr << "Network error in receiveGameState: " << e.what() << "\n";
			running = false;
		}
		catch (...) {
			std::cerr << "Unknown error occurred in receiveGameState.\n";
			running = false;
		}
	}

private:
	asio::io_context& io_context_;
	tcp::socket socket_;
	std::mutex writeMutex;
};

int main(int argc, char* argv[]) {
	asio::io_context io_context;
	PongClient client(io_context);

	try {
		client.connect("127.0.0.1", "12345");
	}
	catch (const std::exception& e) {
		std::cerr << "Connection failed: " << e.what() << "\n";
		return -1;
	}

	// Start network receiving thread
	std::thread receiveThread(&PongClient::receiveGameState, &client);

	// SDL Initialization
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		std::cerr << "SDL Init Failed: " << SDL_GetError() << "\n";
		running = false;
	}
	if (TTF_Init() == -1) {
		std::cerr << "Failed to initialize SDL_ttf: " << TTF_GetError() << std::endl;
		SDL_Quit();
		return -1;
	}
	SDL_Window* window = SDL_CreateWindow("Pong Client",
		SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1200, 800, SDL_WINDOW_SHOWN);
	if (!window) {
		std::cerr << "Window Creation Failed: " << SDL_GetError() << "\n";
		SDL_Quit();
		running = false;
	}

	SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
	if (!renderer) {
		std::cerr << "Renderer Creation Failed: " << SDL_GetError() << "\n";
		SDL_DestroyWindow(window);
		SDL_Quit();
		running = false;
	}

	Scene scene;

	auto player1 = scene.createGameObject("Player1");
	player1->addComponent<SDLRectRenderer>(renderer);
	player1->addComponent<Transform>();
	player1->getComponent<Transform>()->scale = Vector2(25, 120); // Size of paddle
	player1->getComponent<Transform>()->position = Vector2(50, 400 );

	auto player2 = scene.createGameObject("Player2");
	player2->addComponent<Transform>();
	player2->addComponent<SDLRectRenderer>(renderer);
	player2->getComponent<Transform>()->scale = Vector2(25, 120); // Size of paddle
	player2->getComponent<Transform>()->position = Vector2(1150 , 400 );

	auto* ball = scene.createGameObject("Ball");
	ball->addComponent<SDLCircleRenderer>(renderer);
	ball->addComponent<Transform>();
	ball->getComponent<Transform>()->scale = Vector2(10, 10); // Size of ball
	ball->getComponent<Transform>()->position = Vector2(600, 400);

	TTF_Font* font = LoadFont("Font/monogram.ttf", 50); // Adjust font size as needed
	if (font == nullptr)
	{
		// Handle error (already logged in LoadFont)
		SDL_DestroyRenderer(renderer);
		SDL_DestroyWindow(window);
		TTF_Quit();
		SDL_Quit();
		return 1;
	}
	SDL_Event event;

	while (running) {
		// Event handling
		while (SDL_PollEvent(&event)) {
			if (event.type == SDL_QUIT) {
				running = false;
			}
		}

		// Input handling
		const Uint8* keys = SDL_GetKeyboardState(NULL);
		std::string input;

		if (keys[SDL_SCANCODE_W] || keys[SDL_SCANCODE_UP]) {
			input = "UP";
		}
		else if (keys[SDL_SCANCODE_S] || keys[SDL_SCANCODE_DOWN]) {
			input = "DOWN";
		}
		else {
			input = "NONE";
		}

		try {
			if (input != "NONE")
				client.sendInput(input);
		}
		catch (const std::exception& e) {
			std::cerr << "Error sending input: " << e.what() << "\n";
			running = false;
		}

		if (isServerGameStarted)
		{
			ball->getComponent<Transform>()->position.x +=gameState.ball_x_velocity;
			ball->getComponent<Transform>()->position.y += gameState.ball_y_velocity;
		}
		// Render game state
		{
			std::lock_guard<std::mutex> lock(gameStateMutex);

			SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Clear screen
			SDL_RenderClear(renderer);

			//render player1 score
			RenderText(renderer, font, std::to_string(gameState.player1_score), { 255, 255, 255, 255 }, 550, 50);
			//render player2 score
			RenderText(renderer, font, std::to_string(gameState.player2_score), { 255, 255, 255, 255 }, 650, 50);


			// Draw player paddles
			player1->getComponent<Transform>()->position.y = gameState.player1_y;
			player2->getComponent<Transform>()->position.y = gameState.player2_y ;

			/*SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

			SDL_Rect paddle1 = { 50 - 12, gameState.player1_y - 60, 25, 120 };
			SDL_Rect paddle2 = { 1150 - 12, gameState.player2_y - 60, 25, 120 };
			SDL_RenderFillRect(renderer, &paddle1);
			SDL_RenderFillRect(renderer, &paddle2);*/

			// Draw ball
			ball->getComponent<Transform>()->position.x = gameState.ball_x;
			ball->getComponent<Transform>()->position.y = gameState.ball_y;

			//SDL_Rect ball = { gameState.ball_x - 5, gameState.ball_y - 5, 10, 10 };
			//SDL_RenderFillRect(renderer, &ball);




			scene.render(); // Render scene

			SDL_RenderPresent(renderer);
		}

		SDL_Delay(8); // Approximate 120 FPS
	}

	receiveThread.join();
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;
}