// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMESTATE_PONGGAME_H_
#define FLATBUFFERS_GENERATED_GAMESTATE_PONGGAME_H_

#include "flatbuffers/flatbuffers.h"

namespace PongGame {

    struct Vector2;

    struct GameState;

    FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
    private:
        int32_t x_;
        int32_t y_;

    public:
        Vector2() {
            memset(static_cast<void*>(this), 0, sizeof(Vector2));
        }
        Vector2(int32_t _x, int32_t _y)
            : x_(flatbuffers::EndianScalar(_x)),
            y_(flatbuffers::EndianScalar(_y)) {
        }
        int32_t x() const {
            return flatbuffers::EndianScalar(x_);
        }
        int32_t y() const {
            return flatbuffers::EndianScalar(y_);
        }
    };
    FLATBUFFERS_STRUCT_END(Vector2, 8);

    struct GameState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_BALL = 4,
            VT_PLAYER1_Y = 6,
            VT_PLAYER2_Y = 8,
            VT_PLAYER1_SCORE = 10,
            VT_PLAYER2_SCORE = 12,
            VT_BALL_VELOCITY = 14
        };
        const Vector2* ball() const {
            return GetStruct<const Vector2*>(VT_BALL);
        }
        int32_t player1_y() const {
            return GetField<int32_t>(VT_PLAYER1_Y, 0);
        }
        int32_t player2_y() const {
            return GetField<int32_t>(VT_PLAYER2_Y, 0);
        }
        int32_t player1_score() const {
            return GetField<int32_t>(VT_PLAYER1_SCORE, 0);
        }
        int32_t player2_score() const {
            return GetField<int32_t>(VT_PLAYER2_SCORE, 0);
        }
        const Vector2* ball_velocity() const {
            return GetStruct<const Vector2*>(VT_BALL_VELOCITY);
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) &&
                VerifyField<Vector2>(verifier, VT_BALL) &&
                VerifyField<int32_t>(verifier, VT_PLAYER1_Y) &&
                VerifyField<int32_t>(verifier, VT_PLAYER2_Y) &&
                VerifyField<int32_t>(verifier, VT_PLAYER1_SCORE) &&
                VerifyField<int32_t>(verifier, VT_PLAYER2_SCORE) &&
                VerifyField<Vector2>(verifier, VT_BALL_VELOCITY) &&
                verifier.EndTable();
        }
    };

    struct GameStateBuilder {
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_ball(const Vector2* ball) {
            fbb_.AddStruct(GameState::VT_BALL, ball);
        }
        void add_player1_y(int32_t player1_y) {
            fbb_.AddElement<int32_t>(GameState::VT_PLAYER1_Y, player1_y, 0);
        }
        void add_player2_y(int32_t player2_y) {
            fbb_.AddElement<int32_t>(GameState::VT_PLAYER2_Y, player2_y, 0);
        }
        void add_player1_score(int32_t player1_score) {
            fbb_.AddElement<int32_t>(GameState::VT_PLAYER1_SCORE, player1_score, 0);
        }
        void add_player2_score(int32_t player2_score) {
            fbb_.AddElement<int32_t>(GameState::VT_PLAYER2_SCORE, player2_score, 0);
        }
        void add_ball_velocity(const Vector2* ball_velocity) {
            fbb_.AddStruct(GameState::VT_BALL_VELOCITY, ball_velocity);
        }
        explicit GameStateBuilder(flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        GameStateBuilder& operator=(const GameStateBuilder&);
        flatbuffers::Offset<GameState> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<GameState>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<GameState> CreateGameState(
        flatbuffers::FlatBufferBuilder& _fbb,
        const Vector2* ball = 0,
        int32_t player1_y = 0,
        int32_t player2_y = 0,
        int32_t player1_score = 0,
        int32_t player2_score = 0,
        const Vector2* ball_velocity = 0) {
        GameStateBuilder builder_(_fbb);
        builder_.add_ball_velocity(ball_velocity);
        builder_.add_player2_score(player2_score);
        builder_.add_player1_score(player1_score);
        builder_.add_player2_y(player2_y);
        builder_.add_player1_y(player1_y);
        builder_.add_ball(ball);
        return builder_.Finish();
    }

    inline const PongGame::GameState* GetGameState(const void* buf) {
        return flatbuffers::GetRoot<PongGame::GameState>(buf);
    }

    inline const PongGame::GameState* GetSizePrefixedGameState(const void* buf) {
        return flatbuffers::GetSizePrefixedRoot<PongGame::GameState>(buf);
    }

    inline bool VerifyGameStateBuffer(
        flatbuffers::Verifier& verifier) {
        return verifier.VerifyBuffer<PongGame::GameState>(nullptr);
    }

    inline bool VerifySizePrefixedGameStateBuffer(
        flatbuffers::Verifier& verifier) {
        return verifier.VerifySizePrefixedBuffer<PongGame::GameState>(nullptr);
    }

    inline void FinishGameStateBuffer(
        flatbuffers::FlatBufferBuilder& fbb,
        flatbuffers::Offset<PongGame::GameState> root) {
        fbb.Finish(root);
    }

    inline void FinishSizePrefixedGameStateBuffer(
        flatbuffers::FlatBufferBuilder& fbb,
        flatbuffers::Offset<PongGame::GameState> root) {
        fbb.FinishSizePrefixed(root);
    }

}  // namespace PongGame

#endif  // FLATBUFFERS_GENERATED_GAMESTATE_PONGGAME_H_
